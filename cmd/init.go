package cmd

import (
	"fmt"
	"os"
	"path/filepath"

	"github.com/spf13/cobra"
)

var (
	initCmd = &cobra.Command{
		Use:     "initialize",
		Aliases: []string{"init"},
		Short:   "Initializes the hooks as defined in the .hookz.yaml file.",
		Long:    "Initializes the hooks as defined in the .hookz.yaml file.",
		Run: func(cmd *cobra.Command, args []string) {
			hookzHeader()
			fmt.Println("Initializing git hooks...")
			if isErrorBool(writeHooks(), "[ERROR]") {
				return
			}
			fmt.Println("\nDONE!")
		},
	}
)

func init() {
	rootCmd.AddCommand(initCmd)
	initCmd.PersistentFlags().BoolVarP(&Verbose, "verbose", "v", false, "If true, output from commands is displayed when the hook executes.")
}

func createFile(name string) error {

	var _, err = os.Stat(name)

	if os.IsNotExist(err) {
		var file, err = os.Create(name)
		if err != nil {
			return err
		}

		defer file.Close()
	}

	return nil
}

func writeHooks() error {
	var config, err = readConfig()
	if err != nil {
		return err
	}

	exitCodeBlock := `
commandexit=$?

if [ $commandexit -eq 0 ]
then
	echo -e "$blackText$green PASS $reset Hookz: $name ($type)"
else
	echo -e "$blackText$red FAIL $reset Hookz: $name ($type)"
	exit $commandexit
fi
`
	for _, hook := range config.Hooks {
		header := `#!/bin/bash

# This file was generated by Hookz
# For more information, check out https://github.com/devops-kung-fu/hookz
# Built because Python sucks by The DevOps Kung Fu Masters (https://dkf.wtf)


reset='\033[0m'        # Text Reset
red='\033[41m'         # Red
green='\033[42m'       # Green

blackText='\033[0;30m'

		
		`

		filename, _ := filepath.Abs(fmt.Sprintf(".git/hooks/%s", hook.Type))
		hookzFile, _ := filepath.Abs(fmt.Sprintf(".git/hooks/%s.hookz", hook.Type))

		createFile(filename)
		createFile(hookzFile)

		err = os.Chmod(filename, 0777)
		if err != nil {
			return err
		}

		var file, err = os.OpenFile(filename, os.O_APPEND|os.O_WRONLY, 0644)
		if err != nil {
			return err
		}
		_, err = file.WriteString(fmt.Sprintf("%s", header))
		if err != nil {
			return err
		}

		defer file.Close()

		for _, action := range hook.Actions {
			var argsString string
			for _, arg := range action.Args {
				argsString = fmt.Sprintf("%s %s", argsString, arg)
			}

			if action.URL != nil {
				filename, _ := downloadURL(*action.URL)
				action.Exec = &filename
			}
			_, err = file.WriteString(fmt.Sprintf("name='%s'\ntype='%s'\n", action.Name, hook.Type))
			if err != nil {
				return err
			}

			if action.Exec != nil {
				if Verbose {
					_, err = file.WriteString(fmt.Sprintf("echo '[*] Executing %s: %s'\n", hook.Type, action.Name))
					if err != nil {
						return err
					}
					_, err = file.WriteString(fmt.Sprintf("%s%s\n%s", *action.Exec, argsString, exitCodeBlock))
				} else {
					_, err = file.WriteString(fmt.Sprintf("%s%s &> /dev/null\n %s", *action.Exec, argsString, exitCodeBlock))
				}
				if err != nil {
					return err
				}
			}
		}

		err = file.Sync()
		if err != nil {
			return err
		}
		fmt.Println("[*] Successfully wrote " + hook.Type)

	}
	return nil
}
