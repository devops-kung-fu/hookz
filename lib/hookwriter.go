//Package lib Functionality for the Hookz CLI
package lib

import (
	"fmt"
	"os"
	"strings"
	"text/template"

	"github.com/segmentio/ksuid"
)

type command struct {
	Name         string
	Type         string
	ShortCommand string
	FullCommand  string
	Verbose      bool
}

func (f FileSystem) CreateFile(name string) (err error) {

	file, err := f.fs.Create(name)
	if err != nil {
		return err
	}

	defer func() {
		err = file.Close()
	}()

	return
}

func (f FileSystem) CreateScriptFile(content string) (name string, err error) {

	k, idErr := ksuid.NewRandom()
	name = k.String()
	if IsErrorBool(idErr, "ERROR") {
		err = idErr
		return
	}
	path, _ := os.Getwd()
	p := fmt.Sprintf("%s/%s", path, ".git/hooks")

	hookzFile := fmt.Sprintf("%s/%s.hookz", p, name)
	scriptName := fmt.Sprintf("%s/%s", p, name)

	err = f.CreateFile(hookzFile)
	if err != nil {
		return
	}

	err = f.Afero().WriteFile(scriptName, []byte(content), 0644)
	if err != nil {
		return
	}

	err = f.fs.Chmod(scriptName, 0777)
	if err != nil {
		return
	}

	return
}

func buildFullCommand(action Action, verbose bool) string {
	var argsString, fullCommand string
	for _, arg := range action.Args {
		argsString = fmt.Sprintf("%s %s", argsString, arg)
	}
	if action.Exec != nil {
		if verbose {
			fullCommand = fmt.Sprintf("%s%s", *action.Exec, argsString)
		} else {
			fullCommand = fmt.Sprintf("%s%s &> /dev/null", *action.Exec, argsString)
		}
	}
	return fullCommand
}

func (f FileSystem) WriteHooks(config Configuration, verbose bool) (err error) {

	for _, hook := range config.Hooks {
		var commands []command

		for _, action := range hook.Actions {
			if action.Exec == nil && action.URL != nil {
				filename, _ := f.DownloadURL(*action.URL)
				action.Exec = &filename
			}
			if action.Exec == nil && action.Script != nil {
				scriptFileName, err := f.CreateScriptFile(*action.Script)
				if err != nil {
					return err
				}
				path, _ := os.Getwd()
				fullScriptFileName := fmt.Sprintf("%s/%s/%s", path, ".git/hooks", scriptFileName)
				action.Exec = &fullScriptFileName
			}

			fmt.Printf("    	Adding %s action: %s\n", hook.Type, action.Name)

			fullCommand := buildFullCommand(action, verbose)

			commands = append(commands, command{
				Name:         action.Name,
				Type:         hook.Type,
				ShortCommand: *action.Exec,
				FullCommand:  fullCommand,
				Verbose:      verbose,
			})
		}
		err = f.writeTemplate(commands, hook.Type)
		if err != nil {
			return
		}
	}
	return nil
}

func (f FileSystem) writeTemplate(commands []command, hookType string) (err error) {
	path, _ := os.Getwd()
	p := fmt.Sprintf("%s/%s", path, ".git/hooks")

	hookzFile := fmt.Sprintf("%s/%s.hookz", p, hookType)
	err = f.CreateFile(hookzFile)
	if err != nil {
		return
	}

	fmt.Printf("\n[*] Writing %s \n", hookType)
	filename := fmt.Sprintf("%s/%s", p, hookType)
	file, err := f.Afero().Create(filename)
	if err != nil {
		return err
	}
	t := genTemplate(hookType)
	err = t.ExecuteTemplate(file, hookType, commands)
	if err != nil {
		return err
	}
	err = f.fs.Chmod(filename, 0777)
	if err != nil {
		return err
	}
	fmt.Println("[*] Successfully wrote " + hookType)
	return
}

func (f FileSystem) HasExistingHookz() (exists bool) {
	path, _ := os.Getwd()
	ext := ".hookz"
	p := fmt.Sprintf("%s/%s", path, ".git/hooks")
	dirFiles, _ := f.Afero().ReadDir(p)

	for index := range dirFiles {
		file := dirFiles[index]

		name := file.Name()
		fullPath := fmt.Sprintf("%s/%s", p, name)
		info, _ := f.Afero().Stat(fullPath)
		isHookzFile := strings.Contains(info.Name(), ext)
		if isHookzFile {
			return true
		}
	}

	return false
}

func genTemplate(hookType string) (t *template.Template) {

	content := `#!/bin/bash

# This file was generated by Hookz
# For more information, check out https://github.com/devops-kung-fu/hookz

reset='\033[0m'         # Text Reset
red='\033[41m'          # Red Background
green='\033[42m'        # Green Background
blackText='\033[0;30m'  # Black Text
yellowText='\033[0;33m' # Purple Text
boldWhite='\e[1m'  		# Bold White
orange='\e[30;48;5;208m'	# Orange Background

echo -e "\e[1mHookz: Running $(basename $0)$reset"

{{range .}}

if {{.Verbose}}; then
	echo -e "$yellowText >> START: {{.Name}}$reset"
fi

if ! [ -x "$(command -v  {{.ShortCommand}})" ]; then
	echo -e "$blackText$orange WARN $reset Hookz: {{.ShortCommand}} cannot be run. Command doesn't exist.({{.Type}})"
else

	{{.FullCommand}}
		
if {{.Verbose}}; then
	echo -e "$yellowText >> END: {{.Name}}$reset"
fi

	commandexit=$?

	if [ $commandexit -eq 0 ]
	then
			echo -e "$blackText$green PASS $reset Hookz: {{.Name}} ({{.Type}})"
	else
			echo -e "$blackText$red FAIL $reset Hookz: {{.Name}} ({{.Type}})"
			exit $commandexit
	fi
fi



{{end}}
`
	return template.Must(template.New(hookType).Parse(content))
}
