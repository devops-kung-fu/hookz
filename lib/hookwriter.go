//Package lib Functionality for the Hookz CLI
package lib

import (
	"fmt"
	"os"
	"path/filepath"
	"text/template"

	"github.com/segmentio/ksuid"
)

type command struct {
	Name         string
	Type         string
	ShortCommand string
	FullCommand  string
}

func createFile(name string) (err error) {

	file, err := os.Create(name)
	if err != nil {
		return err
	}

	defer func() {
		err = file.Close()
	}()

	return
}

func createScriptFile(content string) (name string, err error) {

	k, idErr := ksuid.NewRandom()
	name, _ = filepath.Abs(fmt.Sprintf(".git/hooks/%s", k.String()))
	if IsErrorBool(idErr, "ERROR") {
		err = idErr
		return
	}
	hookzFile, hookzFileErr := filepath.Abs(fmt.Sprintf(".git/hooks/%s.hookz", k.String()))
	if hookzFileErr != nil {
		err = hookzFileErr
		return
	}
	err = createFile(hookzFile)
	if err != nil {
		return
	}

	file, err := os.OpenFile(name, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0644)
	if err != nil {
		return
	}
	_, err = file.WriteString(content)
	if err != nil {
		return
	}

	defer func() {
		err = file.Close()
	}()

	err = os.Chmod(name, 0777)
	if err != nil {
		return
	}

	return
}

func WriteHooks(config Configuration, verbose bool) (err error) {

	for _, hook := range config.Hooks {
		var commands []command

		filename, _ := filepath.Abs(fmt.Sprintf(".git/hooks/%s", hook.Type))
		hookzFile, _ := filepath.Abs(fmt.Sprintf(".git/hooks/%s.hookz", hook.Type))

		err = createFile(hookzFile)
		if err != nil {
			return err
		}

		var file, err = os.OpenFile(filename, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0644)
		if err != nil {
			return err
		}

		defer func() {
			err = file.Close()
		}()

		fmt.Printf("\n[*] Writing %s \n", hook.Type)

		for _, action := range hook.Actions {

			var argsString string
			for _, arg := range action.Args {
				argsString = fmt.Sprintf("%s %s", argsString, arg)
			}

			if action.Exec == nil && action.URL != nil {
				filename, _ := DownloadURL(*action.URL)
				action.Exec = &filename
			}

			if action.Exec == nil && action.Script != nil {
				scriptFileName, err := createScriptFile(*action.Script)
				if err != nil {
					return err
				}
				action.Exec = &scriptFileName
			}

			fmt.Printf("    	Adding %s action: %s\n", hook.Type, action.Name)

			var fullCommand string
			if action.Exec != nil {
				if verbose {
					fullCommand = fmt.Sprintf("%s%s", *action.Exec, argsString)
				} else {
					fullCommand = fmt.Sprintf("%s%s &> /dev/null", *action.Exec, argsString)
				}
			}

			commands = append(commands, command{
				Name:         action.Name,
				Type:         hook.Type,
				ShortCommand: *action.Exec,
				FullCommand:  fullCommand,
			})
		}

		t := genTemplate(hook.Type)
		err = t.ExecuteTemplate(file, hook.Type, commands)
		if err != nil {
			return err
		}
		err = os.Chmod(filename, 0777)
		if err != nil {
			return err
		}
		fmt.Println("[*] Successfully wrote " + hook.Type)
	}
	return nil
}

func genTemplate(hookType string) (t *template.Template) {

	content := `#!/bin/bash

# This file was generated by Hookz
# For more information, check out https://github.com/devops-kung-fu/hookz

reset='\033[0m'         # Text Reset
red='\033[41m'          # Red Background
green='\033[42m'        # Green Background
blackText='\033[0;30m'  # Black Text
boldWhite='\033[1;37m'  # Bold White
orange='\e[30;48;5;208m'	# Orange Background

{{range .}}

if ! [ -x "$(command -v  {{.ShortCommand}})" ]; then
	echo -e "$blackText$orange WARN $reset Hookz: {{.ShortCommand}} cannot be run. Command doesn't exist.({{.Type}})"
else
	{{.FullCommand}}
		
	commandexit=$?

	if [ $commandexit -eq 0 ]
	then
			echo -e "$blackText$green PASS $reset Hookz: {{.Name}} ({{.Type}})"
	else
			echo -e "$blackText$red FAIL $reset Hookz: {{.Name}} ({{.Type}})"
			exit $commandexit
	fi
fi
{{end}}
`
	return template.Must(template.New(hookType).Parse(content))
}
